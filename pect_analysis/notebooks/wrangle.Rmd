---
title: "wrangle"
output: html_notebook
---

This notebook is written to document the process of the data wrangling from Scratch Dispatcher's output.
First we load the necessary libraries. 
```{r, echo = FALSE, include = FALSE}
library(tidyverse)
```

Then we load the dataset()
```{r, echo = FALSE, include = FALSE}

#HELPER FUNCTIONS
#Returns a boolean to determine if the more than n blocks exists in the data set
#int n: the number of blocks to check
#string blockname: the name of the block to check
#dataframe dt: the dataframe to check
#Example: If blockname = "doifelse" and n = 1, it returns a TRUE if there exists more than 1 doifelse blocks in 
#the dataset
checkBlock = function(dt,blockname,n = 0){
  return(nrow(filter(dt, block==blockname)) != 0 && filter(dt, block==blockname)$count > n)
}

#Helper function used in compute dataset return a boolean to check if the characters in the block array #exists in the data set
#n: threshold of num of blocks to check
checkBlockArray = function(dt,blockArray,n = 0){
  for (i in 1:length(blockArray)){
    if (nrow(filter(dt, block==blockArray[i])) != 0 && filter(dt, block==blockArray[i])$count > n){
      return(TRUE)
    }
  }
  return(FALSE)
}

#Helper function to compute evidence variables for each project. 
#Returns a data frame containing category with its scores, as well as userID and projectID 
#format: userID / projectID / operators score / variables score / other categories...
computeProject = function(dfkey, project, userIDnum, projectIDnum){
  #initialize final data frame
  dt_return = as.tibble(data.frame(category = character(), ev_score = integer()))
  dt_return$category = as.character(dt_return$category)
  categoryVec = unique(dfkey$category) #list of categories (operators, etc.)
#compute for each category 
  for (i in 1:length(categoryVec)){
      category_dt = filter(project,category == categoryVec[i]) 
      #if category exists in project, get maximum score
      if (!nrow(category_dt)==0) score_dt = c(categoryVec[i],max(category_dt$score)) 
       else score_dt = c(categoryVec[i],0) #else set it to zero
      dt_return[i,] = score_dt #put in final data frame
  }
  #assume for variables and sequences
  #for variables, always assume 1, as we assume a sprite is initialized in every project
  if (filter(dt_return,category=="variables")$ev_score == 0) { #if 0, change to 1
    dt_return[dt_return$category=="variables",2] = 1
  }
  #for sequences, assume 1 if green flag block present
  if (filter(dt_return,category=="seq_looping")$ev_score == 0 & checkBlock(project,"whengreenflag")) {
    dt_return[dt_return$category=="seq_looping",2] = 1
  }
  
  #compute parallelization, initialize location, and initialize looks
  #parallelization = 1 if 2 sprites start at same event, i.e. when two green flag blocks are present
  if(checkBlock(project,"whengreenflag",1)) {
    dt_return[11,] = c("parallelization",1)
  } else {
    dt_return[11,] = c("parallelization",0)
  }
  
  #if more than one doifelse, assume nested ifelse 
  if (checkBlockArray(project,c("doifelse","doif","doforeverif"),1)){
    dt_return[dt_return$category=="conditional",2] = 3
  }
  
  #initialize location = 1 if green flag block is present(eventhatmorphstartclicked) and setxpos and setypos also exists
  if(checkBlock(project,"whengreenflag") & (checkBlock(project,"xpos") |checkBlock(project,"ypos"))) {
    dt_return[12,] = c("initialize_location",1)
  } else {
    dt_return[12,] = c("initialize_location",0)
  }
  
  lookBlocks = filter(filter(dfkey,category=="looks"), score != 1)
  #initialize looks = 1 if green flag block is present and looks exist (except say and think)
  if(checkBlock(project,"whengreenflag") & (checkBlockArray(project,lookBlocks$block)))   {
    dt_return[13,] = c("initialize_looks",1)
  } else {
    dt_return[13,] = c("initialize_looks",0)
  }
  dt_return_final = data.frame(rbind(dt_return$ev_score))
  colnames(dt_return_final) = dt_return$category
  dt_return_final = cbind(userID = c(userIDnum), projectID = c(projectIDnum),dt_return_final)
  return(dt_return_final)
}

#NEED TO NOT BE PLATFORM BASED
df = read_csv("/Users/TimGimi/sageMaster/scratch-analyzer/example_input_output/Output/RegularOutput/dispatched/dispatch_perProject.csv")
colnames(df) = c("userID","projectID","block","count")
df = filter(df,!is.na(block))
dfkey = read_csv("/Users/TimGimi/sageMaster/scratch-analyzer/pect_analysis/ev_keys.csv")[,-1]
df$block = tolower(gsub(":","",df$block))
df$block = gsub("_","",df$block)

#initialize list to bind
datalist = list()
k = 1;
#loop through all users
for(i in 1:max(df$userID)){
  user = filter(df,userID==i)
  #loop through all projects
  for(j in 1:max(user$projectID)){
    project = filter(user,projectID==j)
    project = inner_join(project,dfkey,by="block")
    datalist[[k]] = computeProject(dfkey,project,i,j)
    k = k+1 #counter for list
  }
}
#finally bind everything
dfinal = do.call(rbind,datalist)
#prepare test csv
dtest = filter(dfinal, userID == 6)
testName = as.tibble(c("all","basic","developing","inLocation","inLooks","none","parallelmany","parallelOne","proficient"))
colnames(testName) = c("testName")
dtest = cbind(testName,dtest)

#write CSV for all results
write.csv(dfinal,"ev_results.csv")
write.csv(dtest,"ev_tests.csv") #tests
dfinal
```

Visualize the plots
```{r}
#VISUALIZE
ev_name = colnames(dfinal)
for (i in 1:max(dfinal$userID)){
  user = filter(dfinal,userID == i)
  for (j in 1:max(user$projectID)) {
    project_t = slice(as.data.frame(cbind(ev_name,t(filter(user,projectID==j)))),3:15)
    colnames(project_t) = c("ev_name","scores")
    plot = ggplot(data = project_t, aes(x = ev_name, y = scores)) + geom_bar(stat = "identity",colour = "black", fill = "orange", width = 0.7) + xlab("Evidence Variables") + ylab("Scores") + ggtitle(paste("Project ",j," Evidence Variable Scores",sep ='')) + guides(fill=FALSE) + theme(axis.text.x = element_text(angle = 30, hjust = 1))
    dir.create(paste(getwd(),"/plot_users/users",i,sep=""))
    ggsave(paste("project",j,".png",sep=""),plot,path=(paste(getwd(),"/plot_users/users",i,sep="")))
  }
}
# graph = list(graph1,graph2,graph3,graph4)
# ml = marrangeGrob(graph,nrow=2,ncol=1)
# ml
# ggsave("multipage.pdf",ml)
final_t = as.data.frame(t(dfinal))
rownames(dfinal_t) = colnames(dfinal) 

ggplot(data = project_t, aes(x = ev_name, y = scores)) + geom_bar(stat = "identity",colour = "black", fill = "orange", width = 0.7) + xlab("Evidence Variables") + ylab("Scores") + ggtitle(paste("Project ",j," Evidence Variable Scores",sep ='')) + guides(fill=FALSE) + theme(axis.text.x = element_text(angle = 30, hjust = 1))
    dir.create(paste(getwd(),"/users",i,sep=""))
```

Check if blockListWild (Scratch 1.0 Blocknames) the same with blockList in SAGE (Scratch 1.*) and output csv which includes the blocks that are new in SAGE's version of scratch.
ev_keys.csv is updated manually and according to the PECT rubric. Some blocks are new and not mentioned in the PECT thus not indicate any evidence variables.
```{r}
blockListWild = read_csv("/Users/TimGimi/sageMaster/scratch-analyzer/rAnalysis/blockListWild.csv")
blockListSAGE = read_csv("/Users/TimGimi/sageMaster/scratch-analyzer/rAnalysis/blockListSAGE.csv")
blockListWild = blockListWild$Variable
blockListWild = as.tibble(tolower(gsub("_","",blockListWild)))
blockListSAGE = as.tibble(tolower(gsub(":","",blockListSAGE$block)))
colnames(blockListWild) = "block"
colnames(blockListSAGE) = "block"
blockListWild[,2] = rep(1,172)
blockListSAGE[,2] = rep(1,187)
lengthSAGE = length(blockListSAGE$block)
lengthWild = length(blockListWild$block)
notInclude = left_join(blockListSAGE,blockListWild,by="block")
notInclude = notInclude[is.na(notInclude$V2.y),]
write.csv(notInclude, "notInclude.csv")
```

